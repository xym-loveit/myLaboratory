# JVM调优
### Java虚拟机内存模型  
JVM虚拟机将其内存分为：程序计数器、虚拟机栈、本地方法栈、Java堆、方法区  
* 程序计数器：用于存放下一条运行的指令
* 虚拟机栈和本地方法栈：用于存放函数调用堆栈信息
* Java堆：用于存放Java程序运行时所需的对象数据
* 方法区：用于存放程序的类元数据信息


##### 虚拟机栈中的局部变量表中的字（局部变量表以字为单位进行内存的划分，一个字为32位长度）可能会影响GC回收，如果这个字没有被后续代码复用，那么他所引用的对象不会被GC释放。  

##### 本地方法栈：本地方法栈与Java虚拟机的功能很相似，Java虚拟机栈用于管理Java函数的调用，而本地方法栈用于管理本地方法的调用。本地方法并不是用Java实现，而是使用C语言实现的。在SUN的Hot Spot虚拟机中，不区分本地方法栈和虚拟机栈。因此，和虚拟机栈一样，它也会抛出StackOverflowError和OutOfMemoryError。

# JVM内存分配参数  
* -Xmx（最大堆内存），新生代和老年代大小之和的最大值，它是java应用程序的堆上限。

* -Xms（最小堆内存），设置系统最小堆内存，JVM会试图将系统内存尽可能限制在-Xms中，因此，当内存实际使用量触及-Xms指定的大小时，会触发Full GC,因此把-Xms值设置为-Xmx时，可以在系统运行初期减少GC的次数和耗时。

* -Xmn（新生代大小），新生代大小一般为整个堆空间的1/4到1/3左右。（e.g. -Xmx11M -Xms11M -Xmn2M -XX:+PrintGCDetails的最佳Xmn为3.5M）
-Xmx11M -Xms11M -Xmn2M -XX:+PrintGCDetails 偏小  Minor GC次数将增加  （不要这样做）
-Xmx11M -Xms11M -Xmn3.5M -XX:+PrintGCDetails 最佳  Minor GC次数将最少 （按正常比例配置最佳参数，推荐）

* -XX:MaxPermSize（设置持久代最大值）、-XX:PermSize（设置持久代初始大小），持久代的大小直接决定了系统可以支持多少个类定义和多少常量。对于使用CGLIB或Javassist等动态字节码生成工具的应用程序而言，设置合理的持久代大小有助于维持系统稳定。一般推荐最佳参数为64M/128M

* -Xss（设置线程栈大小），如果系统确实需要大量线程并发执行，那么设置一个较小的堆和较小的栈，有助于提高系统所能承受的最大线程数。

#### 堆的比例分配  
参数-XX:SurvivorRatio是用来设置新生代中，eden空间和s0空间的比例关系。s0和s1空间又分别称为form空间和to空间。它们的大小是相同的，职能也是一样的，并在Minor GC后，会互换角色。  
```
-XX:SurvivorRatio=eden/s0=eden/s1
```
-XX:NewRatio可以设置老年代与新生代的比例,可以使用-XX:+PrintGCDetails参数打印出堆的实际大小。


# 对分配参数总结  
与Java应用程序堆内存相关的JVM参数有：  
-Xms：设置Java应用程序启动时的初始堆大小  
-Xmx：设置Java应用程序能获得的最大堆大小  
-Xss：设置线程栈大小  
-XX:MinHeapFreeRatio：设置堆空间最小空闲比例。当堆空间的空闲内存小于这个数值时，JVM便会扩展堆空间。  
-XX:MaxHeapFreeRatio：设置堆空间最大空闲比例。当堆空间的空闲内存大于这个数值时，便会压缩堆空间，得到一个较小的堆。  
-XX:NewSize：设置新生代的大小。  
-XX:NewRatio：设置老年代与新生代的比例，它等于老年代大小除以新生代大小。  
-XX:SurvivorRatio：新生代中eden区与survivor区的比例。
-XX:MaxPermSize：设置最大的持久区大小  
-XX:PermSize：设置持久区的初始值。  
-XX:TargetSurvivorRatio：设置survivor区的可使用率。当survivor区的空间使用率达到这个数值时，会将对象送入老年代。 

直观参见  ![堆分配参数一览][001]

# 垃圾收集基础  

垃圾收集器要处理的基本问题：  
1. 哪些对象需要回收？
2. 何时回收这些对象？
3. 如何回收这些对象？

### 垃圾回收算法与思想  
#### 引用计数法（Reference Counting）  
由于无法处理循环引用的问题，引用计数法不适合用于JVM的垃圾回收。  

#### 标记清除法（Mark-Sweep）  
标记-清除算法（先标记在清除分为二阶段）先通过根节点标记所有可达对象，然后清除所有不可达对象，完成垃圾回收。标记清除算法的最大问题就是空间碎片。  

#### 复制算法（Copying）  
将原有的内存空间分为二块，每次只使用其中的一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。复制算法比较适用于新生代。因为在新生代，垃圾对象通常会多于存活对象，复制算法的效果会比较好。

#### 标记压缩算法（Mark-Compact）  
标记压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记，但之后，它并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端，之后清理边界外所有的空间。这种方法避免了碎片的产生，又不需要两块相同的内存空间，因此性价比较高。  

#### 增量算法（Incremental Collecting）
  
#### 分代（Generational Collecting）  
根据每块内存区间的特点，使用不同的回收算法。如：新生代采用复制算法（幸存对象较少）、老年代使用标记-压缩算法（幸存对象占大部分）

### 垃圾收集器类型  
![垃圾收集器类型][002]














[001]:./堆分配参数一览.png '图形化堆分配参数的含义'
[002]:./垃圾收集器的分类.png '垃圾收集器按不同角度的分类'