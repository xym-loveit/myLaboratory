# JVM调优
### Java虚拟机内存模型  
JVM虚拟机将其内存分为：程序计数器、虚拟机栈、本地方法栈、Java堆、方法区  
* 程序计数器：用于存放下一条运行的指令
* 虚拟机栈和本地方法栈：用于存放函数调用堆栈信息
* Java堆：用于存放Java程序运行时所需的对象数据
* 方法区：用于存放程序的类元数据信息


##### 虚拟机栈中的局部变量表中的字（局部变量表以字为单位进行内存的划分，一个字为32位长度）可能会影响GC回收，如果这个字没有被后续代码复用，那么他所引用的对象不会被GC释放。  

##### 本地方法栈：本地方法栈与Java虚拟机的功能很相似，Java虚拟机栈用于管理Java函数的调用，而本地方法栈用于管理本地方法的调用。本地方法并不是用Java实现，而是使用C语言实现的。在SUN的Hot Spot虚拟机中，不区分本地方法栈和虚拟机栈。因此，和虚拟机栈一样，它也会抛出StackOverflowError和OutOfMemoryError。

# JVM内存分配参数  
* -Xmx（最大堆内存），新生代和老年代大小之和的最大值，它是java应用程序的堆上限。

* -Xms（最小堆内存），设置系统最小堆内存，JVM会试图将系统内存尽可能限制在-Xms中，因此，当内存实际使用量触及-Xms指定的大小时，会触发Full GC,因此把-Xms值设置为-Xmx时，可以在系统运行初期减少GC的次数和耗时。

* -Xmn（新生代大小），新生代大小一般为整个堆空间的1/4到1/3左右。（e.g. -Xmx11M -Xms11M -Xmn2M -XX:+PrintGCDetails的最佳Xmn为3.5M）
-Xmx11M -Xms11M -Xmn2M -XX:+PrintGCDetails 偏小  Minor GC次数将增加  （不要这样做）
-Xmx11M -Xms11M -Xmn3.5M -XX:+PrintGCDetails 最佳  Minor GC次数将最少 （按正常比例配置最佳参数，推荐）

* -XX:MaxPermSize（设置持久代最大值）、-XX:PermSize（设置持久代初始大小），持久代的大小直接决定了系统可以支持多少个类定义和多少常量。对于使用CGLIB或Javassist等动态字节码生成工具的应用程序而言，设置合理的持久代大小有助于维持系统稳定。一般推荐最佳参数为64M/128M

* -Xss（设置线程栈大小），如果系统确实需要大量线程并发执行，那么设置一个较小的堆和较小的栈，有助于提高系统所能承受的最大线程数。

#### 堆的比例分配  
参数-XX:SurvivorRatio是用来设置新生代中，eden空间和s0空间的比例关系。s0和s1空间又分别称为form空间和to空间。它们的大小是相同的，职能也是一样的，并在Minor GC后，会互换角色。  
```
-XX:SurvivorRatio=eden/s0=eden/s1
```
-XX:NewRatio可以设置老年代与新生代的比例,可以使用-XX:+PrintGCDetails参数打印出堆的实际大小。


# 对分配参数总结  
与Java应用程序堆内存相关的JVM参数有：  
-Xms：设置Java应用程序启动时的初始堆大小  
-Xmx：设置Java应用程序能获得的最大堆大小  
-Xss：设置线程栈大小  
-XX:MinHeapFreeRatio：设置堆空间最小空闲比例。当堆空间的空闲内存小于这个数值时，JVM便会扩展堆空间。  
-XX:MaxHeapFreeRatio：设置堆空间最大空闲比例。当堆空间的空闲内存大于这个数值时，便会压缩堆空间，得到一个较小的堆。  
-XX:NewSize：设置新生代的大小。  
-XX:NewRatio：设置老年代与新生代的比例，它等于老年代大小除以新生代大小。  
-XX:SurvivorRatio：新生代中eden区与survivor区的比例。
-XX:MaxPermSize：设置最大的持久区大小  
-XX:PermSize：设置持久区的初始值。  
-XX:TargetSurvivorRatio：设置survivor区的可使用率。当survivor区的空间使用率达到这个数值时，会将对象送入老年代。 

直观参见  ![堆分配参数一览][001]

# 垃圾收集基础  

垃圾收集器要处理的基本问题：  
1. 哪些对象需要回收？
2. 何时回收这些对象？
3. 如何回收这些对象？

### 垃圾回收算法与思想  
#### 引用计数法（Reference Counting）  
由于无法处理循环引用的问题，引用计数法不适合用于JVM的垃圾回收。  

#### 标记清除法（Mark-Sweep）  
标记-清除算法（先标记在清除分为二阶段）先通过根节点标记所有可达对象，然后清除所有不可达对象，完成垃圾回收。标记清除算法的最大问题就是空间碎片。  

#### 复制算法（Copying）  
将原有的内存空间分为二块，每次只使用其中的一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。复制算法比较适用于新生代。因为在新生代，垃圾对象通常会多于存活对象，复制算法的效果会比较好。

#### 标记压缩算法（Mark-Compact）  
标记压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记，但之后，它并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端，之后清理边界外所有的空间。这种方法避免了碎片的产生，又不需要两块相同的内存空间，因此性价比较高。  

#### 增量算法（Incremental Collecting）
  
#### 分代（Generational Collecting）  
根据每块内存区间的特点，使用不同的回收算法。如：新生代采用复制算法（幸存对象较少）、老年代使用标记-压缩算法（幸存对象占大部分）

### 垃圾收集器类型  
![垃圾收集器类型][002]

#### 新生代串行收集器  
串行收集器是所有垃圾回收器中最古老的的一种，也是JDK种最基本的垃圾收集器之一。串行收集器主要有两个特点：第一，它仅仅使用单线程进行垃圾回收；第二，它是独占式的垃圾回收。
![串行垃圾回收][003]  
在Hot Spot虚拟机中，使用-XX:+UseSerialGC参数可以指定使用新生代串行收集器和老年代串行收集器。当JVM在client模式下运行时，它是默认的垃圾收集器。

#### 老年代串行收集器  
若要启用老年代串行回收器，可以使用以下参数：  
* -XX:+UseSerialGC：新生代、老年代都使用串行回收器
* -XX:+UseParNewGC：新生代使用并行收集器，老年代使用串行收集器
* -XX:+UseParallelGC：策略为新生代使用并行清除，年老代使用单线程Mark-Sweep-Compact的垃圾收集器

#### 并行收集器  
* -XX:+UseParNewGC：新生代使用并行收集器，老年代使用串行收集器
    * -XX:+UseConcMarkSweepGC：新生代使用并行收集器，老年代使用CMS  

并行收集器工作时的线程数量可以使用-XX:ParallelGCThreads参数指定。一般，最好与CPU数量相当，避免过多的线程数，影响垃圾收集性能。在默认情况下，当CPU数量小于8个时，ParallelGCThreads的值等于CPU数量；当CPU数量大于8个时，ParallelGCThreads的值等于```3+[(5*CPU_Count)/8]```。
![并行垃圾回收][004] 


#### 新生代并行回收（Parallel Scavenge）收集器（关注于系统的吞吐量）   
新生代并行回收收集器可以使用如下参数启用：  
* -XX:+UseParallelGC：策略为新生代使用并行清除，年老代使用单线程Mark-Sweep-Compact的垃圾收集器  
* -XX:+UseParallelOldGC：新生代和老年代都使用并行回收收集器  
并行回收处理器提供了2个重要的参数用于控制系统的吞吐量：  
1. -XX:MaxGCPauseMillis：设置最大垃圾收集停顿时间，它的值是一个大于0的整数。收集器在工作时，会调整Java堆大小或其他一些参数，尽可能把停顿时间控制在MaxGCPauseMillis以内。如果希望减小停顿时间，而把这个值设置的很小，为了达到预期的停顿时间，JVM可能会使用一个较小的堆（一个小堆比一个大堆回收快），而这将导致垃圾回收得很频繁，从而增加了垃圾回收总时间，降低了吞吐量。

2. -XX:GCTimeRadio：设置吞吐量大小，它的值时一个0~100之间的整数。假设GCTimeRadio的值为n，那么系统将花费不超过1/(1+n)的时间用于垃圾收集。比如GCTimeRadio等于19（默认值），则系统用于垃圾收集的时间不超过1/(1+19)=5%。默认情况下，它的取值是99，既不超过1/(1+99)=1%的时间用于垃圾收集。  
除此之外，并行回收收集器与并行收集器另一个不同之处在于，它还支持一种自适应的GC调节策略。使用-XX:+UseAdaptiveSizePolicy可以打开自适应GC策略。在这种模式下，新生代大小、eden和survivor的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标吞吐量和停顿时间，让虚拟机自己完成调优工作。

#### 老年代并行回收收集器（关注系统的吞吐量）  
老年代并行回收收集器采用标记压缩算法  
![老年代并行回收收集器示意图][005]  

使用-XX:+UseParallelOldGC可以在新生代和老年代都使用并行回收收集器，这是一对非常关注吞吐量的垃圾收集器组合，在对吞吐量敏感的系统中，可以考虑使用。参数-XX:ParallelGCThreads也可以用于设置垃圾回收时的线程数量。

#### CMS收集器  
与并行收集器不同，CMS收集器主要关注系统停顿时间。CMS是Concurrent Mark Sweep的缩写，意为并发标记清除。
从名称上看可以得知，它使用的是标记-清除算法，同时它又是一个使用多线程并行回收的垃圾收集器。CMS工作时主要步骤：初始标记、并发标记、重新标记、并发清除和并发重置。其中初始标记和重新标记是独占资源的，而并发标记、并发清除和并发重置是可以和用户线程一起执行的。因此，从整体上说，CMS收集不是独占式的，它可以在应用程序运行过程中进行垃圾回收。  
![CMS工作示意图][006]
根据标记-清除算法，初始标记、并发标记和重新标记都是为了标记出需要回收的对象。并发清理，则是在标记完成后，正式回收垃圾对象；并发重置是指在垃圾回收完成后，重新初始化CMS数据结构和数据，为一下次垃圾回收做好准备。并发标记、并发清理和并发重置都是可以和应用程序线程一起执行的。  
CMS收集器在其主要的工作阶段虽然没有暴力地彻底暂停应用程序线程，但是由于它和应用程序线程并发执行，相互抢占CPU，故在CMS执行期间对应用程序吞吐量将造成一定影响。CMS默认启动线程数是```（ParallelGCThreads+3）/4```，ParallelGCThreads是新生代并行收集器的线程数，也可以通过-XX:ParallelCMSThreads参数手工设定CMS的线程数量。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用系统的性能在垃圾回收阶段可能会非常糟糕。  
由于CMS收集器不是独占式的回收器，在CMS回收过程中，应用程序仍然在不停的工作。在应用程序工作过程中，又会不断的产生垃圾。这些新生成的垃圾在当前CMS回收过程中无法清除的。同时，因为应用程序没有中断，故在CMS回收过程中，还应该确保应用程序有足够的内存可用。因此，CMS收集器不会等待堆内存饱和时才进行垃圾回收，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中，依然有足够的空间支持 应用程序运行。  
这个回收阈值可以使用-XX:CMSInitiatingOccupancyFraction来指定，默认是68。即，当老年代的空间使用率达到68%时，会执行一次CMS回收。如果应用程序的内存使用率增长很快，在CMS的执行执行过程中，已经出现了内存不足的情况，此时CMS回收就会失败，JVM将启动老年代串行收集器进行垃圾回收。如果这样，应用程序将完全中断，直到垃圾收集完成，这时，应用程序的停顿时间可能很长。  
因此，根据应用程序的特点，可以对-XX:CMSInitiatingOccupancyFraction进行调优。如果内存增长缓慢可以设置一个较大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显的改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。  
CMS是一个基于标记-清除算法的回收器。标记-清除算法将会造成大量内存碎片，离散的可用空间无法分配较大的对象。在这种情况下，即使堆内存仍然有较大的剩余空间，也可能会被迫进行一次垃圾回收，以换取一块可用的连续内存，这种现象对系统性能是相当不利的。为了解决这个问题，CMS收集器还提供了几个用于内存压缩整理的参数。  
```-XX:+UseCMSCompactAtFullCollection```开关可以使CMS在垃圾收集完成后，进行一次碎片整理。内存碎片的整理不是并发进行的。```-XX:CMSFullGCsBeforeCompaction```参数可以用于设定进行多少次CMS回收后，进行一次内存压缩。

#### G1收集器（Garbage First）  
G1收集器采用标记-压缩算法。因此，它不会产生空间碎片，G1收集器还可以进行非常精准的停顿控制，它可以让开发人员指定在长度为M的时间段中，垃圾回收时间不超过N。使用以下参数可以启用G1收集器：  
````-XX:+UnlockExperimentalVMOptions -XX:+UseG1GC```，设置G1回收器的目标停顿时间：```-XX:MaxGCPauseMillis=50 -XX:GCPauseIntervalMillis=200```此参数指定在200ms内，停顿时间不超过50ms，这两个参数是G1回收器的目标，G1回收器并不保证执行他们。

#### 收集器对程序性能的影响  
通过GCTimeTest样例测试程序，观察不同垃圾收集器对应用程序性能的直接影响，测试数据见下表：  

![垃圾收集器对应用程序性能的影响][007]


### GC相关参数总结  
#### 与串行回收器相关的参数
-XX:+UseSerialGC：在新生代和老年代使用串行收集器  
-XX:SurvivorRatio：新生代中eden区与survivor区的比例。  
-XX:PretenureSizeThreshold：设置大对象直接进入老年代的阈值。当对象的大小超过这个值时，将直接在老年代分配。
-XX:MaxTenuringThreshold：设置对象进入老年代的年龄的最大值。每一次MinorGC后，对象年龄就加1。任何大于这个年龄的对象，一定会进入老年代。

#### 与并行GC相关的参数  
-XX:+UseParNewGC：在新生代使用并行收集器  
-XX:+UseParallelOldGC：老年代使用并行回收收集器  
-XX:ParallelGCThreads=8：设置用于垃圾回收的线程数。一般情况下可以和CPU数量相等。但在CPU数量比较多的情况下，设置相对较小的数值也是合理的。
-XX:MaxGCPauseMillis：设置最大垃圾收集停顿时间。它的值是一个大于0的整数。收集器在工作时，会调整Java堆大小或其他参数，尽可能把停顿时间控制在
MaxGCPauseMillis以内。    
-XX:GCTimeRadio：设置吞吐量大小，它的值时一个0~100之间的整数。假设GCTimeRadio的值为n，那么系统将花费不超过1/(1+n)的时间用于垃圾收集。比如GCTimeRadio等于19（默认值），则系统用于垃圾收集的时间不超过1/(1+19)=5%。默认情况下，它的取值是99，既不超过1/(1+99)=1%的时间用于垃圾收集。  
-XX:+UseAdaptiveSizePolicy：可以打开自适应GC策略。在这种模式下，新生代大小、eden和survivor的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标吞吐量和停顿时间，让虚拟机自己完成调优工作。  

#### 与CMS相关的参数  
-XX:+UseConcMarkSweepGC：新生代使用并行收集器，老年代使用CMS+串行收集器。  
-XX:ParallelCMSThreads：设置CMS线程数量  
-XX:CMSInitiatingOccupancyFraction：设置CMS收集器在老年代空间被使用多少后触发，默认为68%。  
-XX:+UseCMSCompactAtFullCollection：开关可以使CMS在垃圾收集完成后，进行一次碎片整理。内存碎片的整理不是并发进行的。  
-XX:CMSFullGCsBeforeCompaction：参数可以用于设定进行多少次CMS回收后，进行一次内存压缩。  
-XX:+CMSClassUnloadingEnabled：允许对类元数据进行回收。  
-XX:+CMSParallelRemarkEnabled：启用并行重标记。
-XX:CMSInitiatingPermOccupancyFraction：当永久区占用率达到这一百分比时，启动CMS回收（前提是-XX:+CMSClassUnloadingEnabled激活了）  
-XX:UseCMSInitiatingOccupancyOnly：表示只在到达阈值的时候，才进行CMS回收。
-XX:+CMSIncrementalMode：设置为增量模式，比较适合单CPU。  

#### 与G1回收器相关的参数  
-XX:+UseG1GC：使用G1回收器  
-XX:+UnlockExperimentalVMOptions：允许使用试验性参数
-XX:MaxGCPauseMillis：设置最大垃圾收集停顿时间  
-XX:GCPauseIntervalMillis：设置停顿间隔时间

#### 其他参数  
-XX:+DisableExplicitGC：禁用显示GC



[001]:./堆分配参数一览.png '图形化堆分配参数的含义'
[002]:./垃圾收集器的分类.png '垃圾收集器按不同角度的分类'
[003]:./串行回收示意图.png '串行收集器工作示意图'
[004]:./新生代并行收集器示意图.png '新生代并行收集器示意图'
[005]:./老年代并行回收收集器示意图.png '老年代并行回收收集器示意图'
[006]:./CMS工作示意图.png 'CMS工作示意图'
[007]:./不同垃圾收集器对程序性能的影响.png '不同垃圾收集器对程序性能的影响'