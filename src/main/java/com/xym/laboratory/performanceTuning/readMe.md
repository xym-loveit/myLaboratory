# JVM调优
### Java虚拟机内存模型  
JVM虚拟机将其内存分为：程序计数器、虚拟机栈、本地方法栈、Java堆、方法区  
* 程序计数器：用于存放下一条运行的指令
* 虚拟机栈和本地方法栈：用于存放函数调用堆栈信息
* Java堆：用于存放Java程序运行时所需的对象数据
* 方法区：用于存放程序的类元数据信息


##### 虚拟机栈中的局部变量表中的字（局部变量表以字为单位进行内存的划分，一个字为32位长度）可能会影响GC回收，如果这个字没有被后续代码复用，那么他所引用的对象不会被GC释放。  

##### 本地方法栈：本地方法栈与Java虚拟机的功能很相似，Java虚拟机栈用于管理Java函数的调用，而本地方法栈用于管理本地方法的调用。本地方法并不是用Java实现，而是使用C语言实现的。在SUN的Hot Spot虚拟机中，不区分本地方法栈和虚拟机栈。因此，和虚拟机栈一样，它也会抛出StackOverflowError和OutOfMemoryError。

# JVM内存分配参数  
* -Xmx（最大堆内存），新生代和老年代大小之和的最大值，它是java应用程序的堆上限。

* -Xms（最小堆内存），设置系统最小堆内存，JVM会试图将系统内存尽可能限制在-Xms中，因此，当内存实际使用量触及-Xms指定的大小时，会触发Full GC,因此把-Xms值设置为-Xmx时，可以在系统运行初期减少GC的次数和耗时。

* -Xmn（新生代大小），新生代大小一般为整个堆空间的1/4到1/3左右。（e.g. -Xmx11M -Xms11M -Xmn2M -XX:+PrintGCDetails的最佳Xmn为3.5M）
-Xmx11M -Xms11M -Xmn2M -XX:+PrintGCDetails 偏小  Minor GC次数将增加  （不要这样做）
-Xmx11M -Xms11M -Xmn3.5M -XX:+PrintGCDetails 最佳  Minor GC次数将最少 （按正常比例配置最佳参数，推荐）

* -XX:MaxPermSize（设置持久代最大值）、-XX:PermSize（设置持久代初始大小），持久代的大小直接决定了系统可以支持多少个类定义和多少常量。对于使用CGLIB或Javassist等动态字节码生成工具的应用程序而言，设置合理的持久代大小有助于维持系统稳定。一般推荐最佳参数为64M/128M

* -Xss（设置线程栈大小），如果系统确实需要大量线程并发执行，那么设置一个较小的堆和较小的栈，有助于提高系统所能承受的最大线程数。

#### 堆的比例分配  
参数-XX:SurvivorRatio是用来设置新生代中，eden空间和s0空间的比例关系。s0和s1空间又分别称为form空间和to空间。它们的大小是相同的，职能也是一样的，并在Minor GC后，会互换角色。  
```
-XX:SurvivorRatio=eden/s0=eden/s1
```
-XX:NewRatio可以设置老年代与新生代的比例,可以使用-XX:+PrintGCDetails参数打印出堆的实际大小。


# 对分配参数总结  
与Java应用程序堆内存相关的JVM参数有：  
-Xms：设置Java应用程序启动时的初始堆大小  
-Xmx：设置Java应用程序能获得的最大堆大小  
-Xss：设置线程栈大小  
-XX:MinHeapFreeRatio：设置堆空间最小空闲比例。当堆空间的空闲内存小于这个数值时，JVM便会扩展堆空间。  
-XX:MaxHeapFreeRatio：设置堆空间最大空闲比例。当堆空间的空闲内存大于这个数值时，便会压缩堆空间，得到一个较小的堆。  
-XX:NewSize：设置新生代的大小。  
-XX:NewRatio：设置老年代与新生代的比例，它等于老年代大小除以新生代大小。  
-XX:SurvivorRatio：新生代中eden区与survivor区的比例。
-XX:MaxPermSize：设置最大的持久区大小  
-XX:PermSize：设置持久区的初始值。  
-XX:TargetSurvivorRatio：设置survivor区的可使用率。当survivor区的空间使用率达到这个数值时，会将对象送入老年代。 

直观参见  ![堆分配参数一览][001]

# 垃圾收集基础  

垃圾收集器要处理的基本问题：  
1. 哪些对象需要回收？
2. 何时回收这些对象？
3. 如何回收这些对象？

### 垃圾回收算法与思想  
#### 引用计数法（Reference Counting）  
由于无法处理循环引用的问题，引用计数法不适合用于JVM的垃圾回收。  

#### 标记清除法（Mark-Sweep）  
标记-清除算法（先标记在清除分为二阶段）先通过根节点标记所有可达对象，然后清除所有不可达对象，完成垃圾回收。标记清除算法的最大问题就是空间碎片。  

#### 复制算法（Copying）  
将原有的内存空间分为二块，每次只使用其中的一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。复制算法比较适用于新生代。因为在新生代，垃圾对象通常会多于存活对象，复制算法的效果会比较好。

#### 标记压缩算法（Mark-Compact）  
标记压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记，但之后，它并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端，之后清理边界外所有的空间。这种方法避免了碎片的产生，又不需要两块相同的内存空间，因此性价比较高。  

#### 增量算法（Incremental Collecting）
  
#### 分代（Generational Collecting）  
根据每块内存区间的特点，使用不同的回收算法。如：新生代采用复制算法（幸存对象较少）、老年代使用标记-压缩算法（幸存对象占大部分）

### 垃圾收集器类型  
![垃圾收集器类型][002]

#### 新生代串行收集器  
串行收集器是所有垃圾回收器中最古老的的一种，也是JDK种最基本的垃圾收集器之一。串行收集器主要有两个特点：第一，它仅仅使用单线程进行垃圾回收；第二，它是独占式的垃圾回收。
![串行垃圾回收][003]  
在Hot Spot虚拟机中，使用-XX:+UseSerialGC参数可以指定使用新生代串行收集器和老年代串行收集器。当JVM在client模式下运行时，它是默认的垃圾收集器。

#### 老年代串行收集器  
若要启用老年代串行回收器，可以使用以下参数：  
* -XX:+UseSerialGC：新生代、老年代都使用串行回收器
* -XX:+UseParNewGC：新生代使用并行收集器，老年代使用串行收集器
* -XX:+UseParallelGC：策略为新生代使用并行清除，年老代使用单线程Mark-Sweep-Compact的垃圾收集器

#### 并行收集器  
* -XX:+UseParNewGC：新生代使用并行收集器，老年代使用串行收集器
* -XX:+UseConcMarkSweepGC：新生代使用并行收集器，老年代使用CMS  

并行收集器工作时的线程数量可以使用-XX:ParallelGCThreads参数指定。一般，最好与CPU数量相当，避免过多的线程数，影响垃圾收集性能。在默认情况下，当CPU数量小于8个时，ParallelGCThreads的值等于CPU数量；当CPU数量大于8个时，ParallelGCThreads的值等于```3+[(5*CPU_Count)/8]```。
![并行垃圾回收][004] 


#### 新生代并行回收（Parallel Scavenge）收集器（关注于系统的吞吐量）   
新生代并行回收收集器可以使用如下参数启用：  
* -XX:+UseParallelGC：策略为新生代使用并行清除，年老代使用单线程Mark-Sweep-Compact的垃圾收集器  
* -XX:+UseParallelOldGC：新生代和老年代都使用并行回收收集器  
并行回收处理器提供了2个重要的参数用于控制系统的吞吐量：  
1. -XX:MaxGCPauseMillis：设置最大垃圾收集停顿时间，它的值是一个大于0的整数。收集器在工作时，会调整Java堆大小或其他一些参数，尽可能把停顿时间控制在MaxGCPauseMillis以内。如果希望减小停顿时间，而把这个值设置的很小，为了达到预期的停顿时间，JVM可能会使用一个较小的堆（一个小堆比一个大堆回收快），而这将导致垃圾回收得很频繁，从而增加了垃圾回收总时间，降低了吞吐量。

2. -XX:GCTimeRadio：设置吞吐量大小，它的值时一个0~100之间的整数。假设GCTimeRadio的值为n，那么系统将花费不超过1/(1+n)的时间用于垃圾收集。比如GCTimeRadio等于19（默认值），则系统用于垃圾收集的时间不超过1/(1+19)=5%。默认情况下，它的取值是99，既不超过1/(1+99)=1%的时间用于垃圾收集。  
除此之外，并行回收收集器与并行收集器另一个不同之处在于，它还支持一种自适应的GC调节策略。使用-XX:+UseAdaptiveSizePolicy可以打开自适应GC策略。在这种模式下，新生代大小、eden和survivor的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标吞吐量和停顿时间，让虚拟机自己完成调优工作。

#### 老年代并行回收收集器  










[001]:./堆分配参数一览.png '图形化堆分配参数的含义'
[002]:./垃圾收集器的分类.png '垃圾收集器按不同角度的分类'
[003]:./串行回收示意图.png '串行收集器工作示意图'
[004]:./新生代并行收集器示意图.png '新生代并行收集器示意图'